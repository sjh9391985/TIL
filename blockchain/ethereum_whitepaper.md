<h1>이더리움 백서</h1>

<h3>이더리움 백서의 개요</h3>

1. 백서의 역사

   - 2013년 이더리움 백서 공개 <br/><br/>

2. 이더리움 백서의 구조

   - 2-1. 비트코인과 기존 개념에 대한 소대
   - 2-2. 이더리움의 기술 요소
   - 2-3. 분산 어플리케이션<br/><br/>

3. 디지털 통화의 역사

   - 일상에서 사용하는 T-Money도 디지털 통화의 일종
   - 1980~90: 개인정보를 보호하는 암호 알고리즘에 기반한 익명 디지털 통화 제안
   - 1988: B-Money는 분산 합의와 퍼즐 계산을 통한 화폐 발행 개념 제시
   - 2005: Hall Finney는 재사용 가능한 작업 증명 방식 제시 -> B-Money에 해시 알고리즘을 적용
   - 2009: 사토시 나카모토에 의해 실제적으로 구현된 탈중앙화 화폐 탄생 -> 비트코인<br/><br/>

4. 작업증명의 혁신
   - 간단하면서 효과적인 합의 알고리즘 제공
   - 누구나 합의 프로세스에 참여할 수 있도록 허용
   - 각 노드의 결정권 크기를 그 노드의 계산 능력에 직접적으로 비례시키는 방식으로 구현 (Hash Rate, Hash Power)<br/><br/>

<h3>비트코인과 기존 기술 개념</h3>

- 비트코인 분산 합의 과정: '블록' 이라는 거래 이력 또는 트랜잭션 묶음의 계속 생성을 위해 노드 필요, 비트코인 네트워크는 10분마다 하나의 블록 생성, 각 블록은 타임스탬프, 논스, 이전 블록의 해시값, 이전 블록 이후 발생한 트랜잭션의 목록 포함<br/><br/>

- 블록 유효성 확인 절차

1. 블록에 의해 참조되는 이전 블록의 존재 \* 유효성 확인
2. 타임스탬프값이 이전 블록의 타임스탬프 값보다 크면서 2시간 이내인지 확인
3. 작업증명(proof of work)의 유효성 확인 ==> 해당 블록의 Hash값과 Nonce, 난이도(Difficulty)를 조합하여 해당 Hash값이 유효성 확인
4. S[0] 을 이전 블록의 마지막 상태(state)가 되도록 설정
5. TX를 n개의 트랜잭션을 가지는 블록의 트랜잭션 목록으로 가정
6. 참(True)을 리턴하고, S[n]을 이블록의 마지막 상태로 등록 (상태가 블록 내에 전혀 저장되지 않음)

   - 상태: 유효성을 검증하는 노드가 매번 계산해서 기억해야 할 완전히 추상적인 것 (원시상태부터 해당 블록까지의 모든 트랜잭션을 순차적으로 적용함으로써 계산)<br/><br/>

- 머클 트리

  - 해시 트리(머클 트리)
    - 노드의 이름이 자식 노드의 이름의 해시값으로 구성된 트리(발명가의 이름을 따서 만듬)
    - 여러 블록으로 구성된 데이터의 무결성을 보장하는 데 사용
    - 전체 데이터의 일부 데이터가 누락, 오류, 변조 될 경우 트리 구조의 오류를 쉽게 발견 가능<br/><br/>

- 블록체인 기술 3가지<br/><br/>
  1.  네임코인
      - 탈중앙화된 명칭 등록 데이터베이스
      - 비트코인 내 ID는 16진수 Hash Code: 식별이 어려운단점이 있는데 이를 해결하기 위해서 명칭을 등록할 수 있는 블록체인 제작
      - 인터넷상에서 계정, 도메인, 식별 가능한 지갑 ID 등을 구현하는데 사용<br/><br/>
  2.  컬러드 코인
      - 비트코인 위에서 개별 암호화폐를 발행 할 수 있는 프로토콜(자신만의 디지털 토큰을 발행하는 프로토콜 역할)
      - 비트코인 UTXO에 색깔(식별자)을 부여함으로써 구현
      - 블록체인을 처음부터 끝까지 역추적해 UTXO 색깔을 정함<br/><br/>
  3.  메타 코인
      - 거래 내역이 비트코인 블록체인 네트워크를 이용하는 개념
      - 비트코인 거래 메커니즘을 메타코인 거래에 이용함
      - 상태 변환 함수를 다르게 가짐
      - 비트코인 시스템 위에 운영되는 프로토콜을 가짐<br/><br/>
